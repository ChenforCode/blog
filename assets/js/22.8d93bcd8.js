(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{567:function(t,l,s){"use strict";s.r(l);var a=s(12),e=Object(a.a)({},(function(){var t=this,l=t.$createElement,s=t._self._c||l;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h4",{attrs:{id:"死锁编码和定位分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁编码和定位分析"}},[t._v("#")]),t._v(" 死锁编码和定位分析")]),t._v(" "),s("ul",[s("li",[t._v("死锁指的是两个或两个以上的进程在执行过程中，因为争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就会很低，否则就会因争夺有限的资源而陷入死锁")]),t._v(" "),s("li",[t._v("写代码，如果有一个locka和lockb，一个线程先拿到locka然后尝试获取lockb，另一个线程相反，那么就会死锁")]),t._v(" "),s("li",[t._v("解决：jps定位到进程号，jstack找到死锁进行查看")])])])}),[],!1,null,null,null);l.default=e.exports}}]);