(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{424:function(v,l,_){"use strict";_.r(l);var i=_(2),e=Object(i.a)({},(function(){var v=this,l=v._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h4",{attrs:{id:"阻塞队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[v._v("#")]),v._v(" 阻塞队列")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("首先是一个队列，然后有一个生产线程会往队列中加入元素，消费线程会从队列中取元素。")]),v._v(" "),l("ul",[l("li",[v._v("当阻塞队列为空时，消费线程（取）会被阻塞")]),v._v(" "),l("li",[v._v("当阻塞队列满时，生产线程（放）会被阻塞")])])]),v._v(" "),l("li",[l("p",[v._v("Collection父接口，有List接口和Queue接口。Queue接口又有BlockingQueue，其实现类有")]),v._v(" "),l("p",[l("img",{attrs:{src:"https://raw.githubusercontent.com/ChenforCode/chen-imagebed/master/img/20210413231526.png",alt:"image-20210413231526466"}})])]),v._v(" "),l("li",[l("p",[v._v("ArrayBlockingQueue")]),v._v(" "),l("ul",[l("li",[v._v("底层是一个数组结构，有界阻塞队列")])])]),v._v(" "),l("li",[l("p",[v._v("LinkedBlockingQueue")]),v._v(" "),l("ul",[l("li",[v._v("链表结构，有界阻塞队列，但是界是Integer.MAX_VALUE")])])]),v._v(" "),l("li",[l("p",[v._v("SynchronousQueue")]),v._v(" "),l("ul",[l("li",[v._v("只能存储一个元素的队列，不取走元素，就永远不生产，取走之后立即生产一个占满队列")])])]),v._v(" "),l("li",[l("p",[v._v("抛出异常组")]),v._v(" "),l("ul",[l("li",[v._v("add，满了再add会抛出异常")]),v._v(" "),l("li",[v._v("remove，空了remove会抛出异常")]),v._v(" "),l("li",[v._v("element")])])]),v._v(" "),l("li",[l("p",[v._v("boolean组")]),v._v(" "),l("ul",[l("li",[v._v("offer")]),v._v(" "),l("li",[v._v("poll")]),v._v(" "),l("li",[v._v("peek")])])]),v._v(" "),l("li",[l("p",[v._v("一直阻塞组")]),v._v(" "),l("ul",[l("li",[v._v("put")]),v._v(" "),l("li",[v._v("take")])])]),v._v(" "),l("li",[l("p",[v._v("超时阻塞")]),v._v(" "),l("ul",[l("li",[v._v("offer")]),v._v(" "),l("li",[v._v("poll")])])]),v._v(" "),l("li",[l("p",[v._v("总结")]),v._v(" "),l("ul",[l("li",[v._v("addremove会抛出异常")]),v._v(" "),l("li",[v._v("put和take会一直阻塞")]),v._v(" "),l("li",[v._v("offer和poll可以温柔的返回true和false以及控制时间的阻塞")])])]),v._v(" "),l("li",[l("p",[v._v("SychronousQueue")])]),v._v(" "),l("li",[l("p",[v._v("传统版的生产者消费者模式")]),v._v(" "),l("p",[l("img",{attrs:{src:"https://raw.githubusercontent.com/ChenforCode/chen-imagebed/master/img/20210414000900.png",alt:"image-20210414000900743"}})]),v._v(" "),l("ul",[l("li",[v._v("如果为空的话，消费线程就等着，直到不为空会被唤醒，然后消费num，接着通知生产者。")]),v._v(" "),l("li",[v._v("生产者线程也是，如果number不为空，那就等着，直到为空被唤醒，就可以开始生产了，生产完唤醒消费者。")]),v._v(" "),l("li",[v._v("注意一点，条件判断要用while")])])]),v._v(" "),l("li",[l("p",[v._v("lock和Sychronized有什么区别")]),v._v(" "),l("ul",[l("li",[v._v("构成方面\n"),l("ul",[l("li",[v._v("Sychronized是关键字，属于JVM层面，底层用了monitorenter和monitorexit关键字")]),v._v(" "),l("li",[v._v("lock是一个api，是juc下的一个类")])])]),v._v(" "),l("li",[v._v("使用方法\n"),l("ul",[l("li",[v._v("Sychronized不需要用户手动释放锁，执行完之后会自动释放对锁的占用")]),v._v(" "),l("li",[v._v("lock需要手动释放")])])]),v._v(" "),l("li",[v._v("是否可中断\n"),l("ul",[l("li",[v._v("Sychronized不可中断，除非抛出异常或者正常运行完成")]),v._v(" "),l("li",[v._v("reentrantlock可终断，可以设置超时方法，超时直接结束。或者手动调用interrupt方法中断")])])]),v._v(" "),l("li",[v._v("加锁是否公平\n"),l("ul",[l("li",[v._v("sychronized默认非公平锁")]),v._v(" "),l("li",[v._v("lock创建默认也是非公平锁，但是可以设置公平锁")])])]),v._v(" "),l("li",[v._v("锁绑定多个条件\n"),l("ul",[l("li",[v._v("sychronized没有")]),v._v(" "),l("li",[v._v("lock可以实现精确唤醒需要唤醒的线程。sychronized只能随机唤醒一个线程或者唤醒全部线程")])])])])]),v._v(" "),l("li",[l("p",[v._v("题目，多个线程按顺序调用，实现A->B->C，要求A打印5次，B打印10次，C打印15次，然后再是A")])])]),v._v(" "),l("p",[l("img",{attrs:{src:"https://raw.githubusercontent.com/ChenforCode/chen-imagebed/master/img/20210416233447.png",alt:"image-20210416233447247"}})]),v._v(" "),l("ul",[l("li",[l("p",[v._v("在加锁内部写方法，1、判断，是否该我这个线程运行。2、干活，确定该我干了就做一些操作。3、唤醒，我干完了，唤醒下一个。首先只要number不是1，c1就一直await，知道有人把number改成1，并且用了c1.signal，c1线程就进入了。代码同理，c1干完之后通知c2")])]),v._v(" "),l("li",[l("p",[v._v("lock是对一个代码加锁，当前只能由一个线程进入。然后条件是为了更加精确的对某个线程进行阻塞和唤醒。")])]),v._v(" "),l("li",[l("p",[v._v("这个执行逻辑是这样。t1加锁，进入")])]),v._v(" "),l("li",[l("p",[v._v("阻塞队列生产者消费者")]),v._v(" "),l("ul",[l("li",[v._v("用阻塞队列的offer和poll方法即可，自动的帮你实现阻塞和唤醒")])])])])])}),[],!1,null,null,null);l.default=e.exports}}]);