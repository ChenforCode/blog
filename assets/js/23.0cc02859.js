(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{578:function(t,l,e){"use strict";e.r(l);var v=e(13),i=Object(v.a)({},(function(){var t=this,l=t.$createElement,e=t._self._c||l;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h4",{attrs:{id:"jvm的体系结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm的体系结构"}},[t._v("#")]),t._v(" jvm的体系结构")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/ChenforCode/chen-imagebed/master/img/20210427152823.png",alt:"image-20210427152823769"}})]),t._v(" "),e("ul",[e("li",[t._v("gc的作用域主要是方法区和堆")]),t._v(" "),e("li",[t._v("gc的方法\n"),e("ul",[e("li",[t._v("引用计数法\n"),e("ul",[e("li",[t._v("计算现在还有多少个引用，加引用+1，杀死引用-1，直到为0就是死了需要kill掉")])])]),t._v(" "),e("li",[t._v("复制算法\n"),e("ul",[e("li",[t._v("mirrorGC：复制，清除，交换")]),t._v(" "),e("li",[t._v("eden满的时候触发第一次gc，剩余对象复制到from区")]),t._v(" "),e("li",[t._v("eden和from再次满的时候，触发第二次gc，剩余对象复制到to区")]),t._v(" "),e("li",[t._v("清除eden和from区")]),t._v(" "),e("li",[t._v("新清除得到的from区变成to区")]),t._v(" "),e("li",[t._v("反复交换15次就将对象扔入老年代")])])]),t._v(" "),e("li",[t._v("标记清除，产生内存碎片")]),t._v(" "),e("li",[t._v("标记整理，在标记清除的基础上，整理内存碎片，缺点是有移动复制的消耗‘")])])]),t._v(" "),e("li",[t._v("JVM垃圾回收的时候如何确定垃圾，是否知道什么是gcroot")]),t._v(" "),e("li")])])}),[],!1,null,null,null);l.default=i.exports}}]);